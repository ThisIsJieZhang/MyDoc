1.run、with、apply、also、let的区别

class Person(var name: String, var age: Int) {

    fun eat() {
        println("吃柠檬")
    }

    fun work(hour: Int): Int {
        println("work $hour hour,earn ￥${hour * 60}")
        return hour * 60
    }
}

with
with()函数是一个内联函数，它把传入的对象作为接受者，在该函数内可以使用this指代该对象来访问其公有的属性和方法。该函数的返回值为函数块最后一行或指定的return表示式。
例：
fun main() {
    val person: Person = Person("hzh", 23)
    val result = with(person) {
        age = 24
        eat()
        work(8) // 返回480
    }
    println("result is:$result")
}

运行结果：

吃柠檬
work 8 hour,earn ￥480
result is:480

fun main() {
    val person: Person = Person("hzh", 23)
    val result = with(person) {
        age = 24
        eat()
        work(8)
        return@with "HaHa" // return表达式，可以省略return@with直接返回最后一行
    }
    println("result is:$result")
}

运行结果：

吃柠檬
work 8 hour,earn ￥480
result is:HaHa

fun main() {
    val person: Person? = Person("hzh", 23)
    val result = with(person) {
        age = 24
        eat()
        work(8)
    }
    println("result is:$result")
}

无法编译:person为可空对象，with()需要在函数块内判定对象是否为空
如：
val result = with(person) {
    this?.age = 24
    this?.eat()
    this?.work(8)
}

with()函数源码:
/**
 * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.
 *
 * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).
 */
@kotlin.internal.InlineOnly
public inline fun <T, R> with(receiver: T, block: T.() -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return receiver.block()
}

let
let()函数是一个扩展对象函数，它可以对被扩展的对象做统一的判空处理，在函数块内使用it来指代该对象，可以访问对象的公有属性和方法。let()函数的返回值和with()函数一样，为函数块最后一行或指定的return表示式。
例：
fun main() {
    val person: Person? = Person("hzh", 23)
    val result = person?.let {
        it.age = 24
        it.eat()
        it.work(8) // 返回480
    }
    println("result is:$result")
}

运行结果：

吃柠檬
work 8 hour,earn ￥480
result is:480

let()函数源码:
/**
 * Calls the specified function [block] with `this` value as its argument and returns its result.
 *
 * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).
 */
@kotlin.internal.InlineOnly
public inline fun <T, R> T.let(block: (T) -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block(this)
}

run
run()函数是with()和let()函数的结合体，它可以像with()函数一样直接在函数块中使用this指代该对象，也可以像let()函数一样为对象做统一的判空处理。
例：
fun main() {
    val person: Person? = Person("hzh", 23)
    val result = person?.run {
        age = 24
        eat()
        work(8) // 返回480
    }
    println("result is:$result")
}

运行结果：

吃柠檬
work 8 hour,earn ￥480
result is:480

run()函数的源码：
/**
 * Calls the specified function [block] with `this` value as its receiver and returns its result.
 *
 * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).
 */
@kotlin.internal.InlineOnly
public inline fun <T, R> T.run(block: T.() -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block()
}

apply
apply()函数和run()函数相似，不同的是，run()函数是以闭包形式返回最后一行代码的值，而apply()函数返回的是传入的对象本身。
例：
fun main() {
    val person: Person? = Person("hzh", 23)
    println("person:$person")
    val result = person?.apply {
        age = 24
        eat()
        work(8) // 返回传入的person对象
    }
    println("result is:$result")
}

运行结果：

person:Person@610455d6
吃柠檬
work 8 hour,earn ￥480
result is:Person@610455d6

apply()函数源码：
/**
 * Calls the specified function [block] with `this` value as its receiver and returns `this` value.
 *
 * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).
 */
@kotlin.internal.InlineOnly
public inline fun <T> T.apply(block: T.() -> Unit): T {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    block()
    return this
}

also
also()函数和apply()函数相似，不同的是，also()函数在函数块中使用it指代该对象，而apply()函数在函数块中使用this指代该对象。
fun main() {
    val person: Person? = Person("hzh", 23)
    println("person:$person")
    val result = person?.also {
        it.age = 24
        it.eat()
        it.work(8) // 返回传入的person对象
    }
    println("result is:$result")
}

运行结果：

person:Person@610455d6
吃柠檬
work 8 hour,earn ￥480
result is:Person@610455d6

also()函数源码：
/**
 * Calls the specified function [block] with `this` value as its argument and returns `this` value.
 *
 * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).
 */
@kotlin.internal.InlineOnly
@SinceKotlin("1.1")
public inline fun <T> T.also(block: (T) -> Unit): T {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    block(this)
    return this
}

区别















































函数名函数块内使用对象返回值是否扩展函数适用场景withthis函数块最后一行或return表达式的值否适用于调用同一个类多个方法letit函数块最后一行或return表达式的值是适用于对象统一处理不为空的情况runthis函数块最后一行或return表达式的值是适用with()、let()函数的任何场景applythis该对象是适用于run()函数的任何场景，通产可用来在初始化一个对象实例时，操作对象属性并最终返回该对象。也可用于多个扩展函数链式调用alsoit该对象是适用于let()函数的任何场景，一般可用于多个扩展函数链式调用
